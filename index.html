<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hexpedition | Home</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div id="chrome">
      <div id="map"></div>
      <div id="controls">
        <!-- 
      // chrome
      // compass rose
      // claim/release scout
      // owner need lock/unlock to prevent map revealing at incorrect times
      // perhaps it could issue a lock after each move so the owner can execute their own agame shit
      -->
        <button type="button">(un)Lock</button>
        <button type="button" disabled>Scout</button>
      </div>
    </div>

    <script src="queue.js"></script>
    <script src="map.js"></script>
    <script>
      const HEX_MAP = {
        id: 1, // this is an instance id
        mapId: 1,
        name: "SO FUCKING WHAT",
        mapHeight: 5, // hexes
        viewRadius: 1, // hexes
        mapData: hex,
        startHex: 21,
        /*
        // or figure this out with math, top and bottom are easy index +/- 1, perhaps left and right are index - mapHeight...
        // index 15 - 20 = -5 which means no left hand siblings
        // index 15 + 20 = 35 and 36 seem to be correct,
        // in fact moving +height would seem to mean index + height && index + height + 1 gives the right siblings
        // and moving -height would seem to mean index - height && index - height - 1 gives the left siblings
      */
      };

      // The idea here is that entering a hex would change state and when state
      // is changed we'd know the ids of the updated hexes.
      // So we record them here so the render engine can change only the 7 updated hexes.
      //   This assumes a view radius of 1. The diff would be different for a largeer view radius.
      const GAME_DATA = {
        MAP: HEX_MAP,
        // diff: [id, id, id, id, id, id, id],
      };

      // function painter(map) {
      //   map.forEach(() => {
      //       if revealed paint icon
      //       else paint empty
      //   });
      // }
      console.log("MAP LENGTH", hex.length);
      function getSiblings(radius = 1, mapHeight, hexIndex, mapLength) {
        const siblings = [];

        const top = hexIndex - 1;
        const bottom = hexIndex + 1;
        const topLeft = hexIndex - mapHeight;
        const bottomLeft = hexIndex - (mapHeight - 1);
        const topRight = hexIndex + mapHeight;
        const bottomRight = hexIndex + mapHeight + 1;
        const cols = Math.ceil(mapLength / mapHeight);
        const colFirstIndex = Math.floor(hexIndex / mapHeight) * mapHeight;
        const colLastIndex = Math.ceil(hexIndex / mapHeight) * mapHeight - 1;
        const prevColFirstIndex = Math.max(colFirstIndex - mapHeight, 0);
        const prevColLastIndex = Math.max(colLastIndex - mapHeight, 0);
        const nextColFirstIndex = Math.min(
          colFirstIndex + mapHeight,
          mapLength
        );
        const nextColLastIndex = Math.min(colLastIndex + mapHeight, mapLength);

        // all imaginary indexes I haven't calculated or sourced yet
        if (top >= colFirstIndex) siblings.push(top);
        if (bottom <= colLastIndex) siblings.push(bottom);
        if (topLeft >= prevColFirstIndex) siblings.push(topLeft);
        if (bottomLeft <= prevColLastIndex) siblings.push(bottomLeft);
        if (topRight >= nextColFirstIndex) siblings.push(topRight);
        if (bottomRight <= nextColLastIndex) siblings.push(bottomRight);

        return siblings;
      }

      function onEnterHex(hex) {
        const siblings = getSiblings(hex.index, viewradius);

        onRevealrHex(hex);
        siblings.forEach((hex) => onViewHex(hex));
      }

      function onRevealrHex(hex) {
        return { ...hex, revealed: true, traversed: true };
      }

      function onViewHex(hex) {
        return { ...hex, revealed: true };
      }

      // So the process becomes
      //  1. user selects hex
      //  2. icon is moved
      //  3. The entered hexes and viewed hexes are calculated and updated ()
      //  4. A diff of ids is produced
      //
      // meanwhile the game loop looks for the diff list and re-renders just those
      // hexes when it's full
      // the diff would therefore need to be a queue that the game loop could access
      // and deplete.
      // the reason I'm thinking queue right now is becuase game state and rendering
      // could operate independently ... both update the queue but the loop
      // doesn't care when the queue is updated it just takes a piece when available
      //
      // Now the diff ids is a good idea locally but if I had to send this over a
      // server then just the ids would be meaningless on another computer. so
      // the diff must naturally be changes hexes that can be merged into local state.

      // but also if I'm sending to a server then I don't think I'd want to merge
      // diff and data so maybe the updated mao passed so the server with the diff id list
      // that way a consunder can replace the board for refreshed and use the diff
      // to get those cells for updating the dome

      // So the process becomes
      //  1. user selects hex
      //    1. But it has to be a sibling hex
      //  2. icon is moved
      //  3. The entered hexes and viewed hexes are calculated and updated ()
      //  4. A diff of ids is produced
      //  5. local ui updates
      //  6. Diff and map update are sent to the server
      //  7. The server saves data and also relays updated data to other users
      //  8.

      // local testing
      // I could get this working in a browser and moving around then worry about pushing to a server
      //

      // upgrade, procediral shit,
      // roll for randos when enter a hex or whatever

      /**
       *
       * @param { HEX } hex
       * @returns { string }
       */
      function terrain(hex) {
        return hex.traversed
          ? hex.traversedTerrain
          : hex.revealed
          ? hex.revealedTerrain
          : "unexplored";
      }

      document.addEventListener("DOMContentLoaded", () => {
        const map = document.getElementById("map");

        map.addEventListener("click", (e) => {
          console.log(165, e.target.classList);
          if (e.target.classList.contains("active")) {
            console.log(e.target.dataset);
          }
        });

        let tpl = ``;
        let open = false;
        const adjacentHexes = getSiblings(
          HEX_MAP.viewRadius,
          HEX_MAP.mapHeight,
          HEX_MAP.startHex,
          HEX_MAP.mapData.length
        );
        console.log(166, adjacentHexes);

        // mapHeight: 5, // hexes
        // viewRadius: 1, // hexes
        // mapData: hex,

        for (let i = 0, ii = HEX_MAP.mapData.length; i < ii; i++) {
          if (!open && (i + 1) % 5 !== 0) {
            // where 5 is map height
            open = true;
            tpl = `${tpl}<div>`;
          }

          const className =
            i === HEX_MAP.startHex
              ? "start"
              : adjacentHexes.includes(i)
              ? "adjacent"
              : "";

          tpl = `${tpl}<div data-key=${i} class="${className}">${terrain(
            HEX_MAP.mapData[i]
          )}</div>`;

          if (open && (i + 1) % 5 === 0) {
            open = false;
            tpl = `${tpl}</div>`;
          }
        }
        map.innerHTML = tpl;
      });
    </script>
    <script>
      // Tile Data
      const TD = {
        id: 0,
        revealed: false,
        terrain: "forest",
        // The IDS of the 6 hexes that border this
        // BUT might need to be larger when the vewRadius is larger
        siblings: [null, null, null, null, null, null],
      };
    </script>
  </body>
</html>
