<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hexpedition | Home</title>
  </head>
  <body>
    <script>
      const HEX_MAP = {
        id: 1, // this is an instance id
        mapId: 1,
        name: "",
        mapHeight: 20, // hexes
        viewRadius: 1, // hexes
        mapData: [
          {
            id: 0,
            revealed: false,
            traversed: false,
            revealedTerrain: "forest",
            traversedTerrain: "forest", // but could be ruin, lair or something else.
            // or figure this out with math, top and bottom are easy index +/- 1, perhaps left and right are index - mapHeight...
            // index 15 - 20 = -5 which means no left hand siblings
            // index 15 + 20 = 35 and 36 seem to be correct,
            //   in fact moving +height would seem to mean index + height && index + height + 1 gives the right siblings
            //   and moving -height would seem to mean index - height && index - height - 1 gives the left siblings
            siblings: [id, id, id, id, id, id],
          },
        ],
      };

      // The idea here is that entering a hex would change state and when state
      // is changed we'd know the ids of the updated hexes.
      // So we record them here so the render engine can change only the 7 updated hexes.
      //   This assumes a view radius of 1. The diff would be different for a largeer view radius.
      const GAME_DATA = {
        MAP: HEX_MAP,
        diff: [id, id, id, id, id, id, id],
      };

      // function painter(map) {
      //   map.forEach(() => {
      //       if revealed paint icon
      //       else paint empty
      //   });
      // }

      function getSiblings(radius = 1, mapHeight, hexIndex) {
        const siblings = [];

        const top = hexIndex - 1;
        const bottom = hexIndex + 1;
        const topLeft = hexIndex - mapHeight;
        const bottomLeft = hexIndex - mapHeight - 1;
        const topRight = hexIndex + mapHeight;
        const bottomRight = hexIndex + mapHeight - 1;

        // all imaginary indexes I haven't calculated or sourced yet
        if (top >= colFirstIndex) siblings.push(top);
        if (bottom <= colLastIndex) siblings.push(bottom);
        if (topLeft >= prevColFirstIndex) siblings.push(topLeft);
        if (bottomLeft <= prevColLastIndex) siblings.push(bottomLeft);
        if (topRight >= nextColFirstIndex) siblings.push(topRight);
        if (bottomRight <= nextColLastIndex) siblings.push(bottomRight);

        return siblings;
      }

      function onEnterHex(hex) {
        const siblings = getSiblings(hex.index, viewradius);

        onRevealrHex(hex);
        siblings.forEach((hex) => onViewHex(hex));
      }

      function onRevealrHex(hex) {
        return { ...hex, revealed: true, traversed: true };
      }

      function onViewHex(hex) {
        return { ...hex, revealed: true };
      }

      // So the process becomes
      //  1. user selects hex
      //  2. icon is moved
      //  3. The entered hexes and viewed hexes are calculated and updated ()
      //  4. A diff of ids is produced
      //
      // meanwhile the game loop looks for the diff list and re-renders just those
      // hexes when it's full
      // the diff would therefore need to be a queue that the game loop could access
      // and deplete.
      // the reason I'm thinking queue right now is becuase game state and rendering
      // could operate independently ... both update the queue but the loop
      // doesn't care when the queue is updated it just takes a piece when available
      //
      // Now the diff ids is a good idea locally but if I had to send this over a
      // server then just the ids would be meaningless on another computer. so
      // the diff must naturally be changes hexes that can be merged into local state.

      // but also if I'm sending to a server then I don't think I'd want to merge
      // diff and data so maybe the updated mao passed so the server with the diff id list
      // that way a consunder can replace the board for refreshed and use the diff
      // to get those cells for updating the dome

      // So the process becomes
      //  1. user selects hex
      //  2. icon is moved
      //  3. The entered hexes and viewed hexes are calculated and updated ()
      //  4. A diff of ids is produced
      //  5. local ui updates
      //  6. Diff and map update are sent to the server
      //  7. The server saves data and also relays updated data to other users
      //  8.

      // local testing
      // I could get this working in a browser and moving around then worry about pushing to a server
      //

      // chrome
      // compass rose
      // claim/release scout
      // owner need lock/unlock to prevent map revealing at incorrect times
      // perhaps it could issue a lock after each move so the owner can execute their own agame shit

      // upgrade, procediral shit,
      // roll for randos when enter a hex or whatever
    </script>
    <script>
      // Tile Data
      const TD = {
        id: 0,
        revealed: false,
        terrain: "forest",
        // The IDS of the 6 hexes that border this
        // BUT might need to be larger when the vewRadius is larger
        siblings: [null, null, null, null, null, null],
      };
    </script>
  </body>
</html>
